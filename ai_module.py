import openai
from typing import List, Tuple
import re

openai_key = "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"

client = openai.OpenAI(api_key=openai_key)

def get_exam_type() -> str:
    try:
        with open("exam_type.txt", "r") as f:
            return f.read().strip()
    except Exception:
        return "General"

def build_prompt(text: str) -> str:
    exam_type = get_exam_type()
    return (
        f"You are an expert in {exam_type} certification exams. Analyze the following text from a practice exam question and extract the question and answer options. For each answer option, provide a percentage in brackets indicating how correct you believe it is, based on {exam_type} best practices and standards.\n\n"
        "Example format:\n"
        "Question: [The actual question text]\n"
        "A (100%) [Answer A text]\n"
        "B (0%) [Answer B text]\n"
        "C (42%) [Answer C text]\n"
        "D (87%) [Answer D text]\n\n"
        "Important:\n"
        "1. Internally, run your answer process twice and compare your answers, but ONLY show the best consolidated answer. Do not show both, do not mention that you ran it twice.\n"
        "2. Do NOT include any explanations or reasoning with your answer, only show the correct answers and their percentages.\n"
        "3. Include a percentage in brackets after each answer option (A, B, C, D)\n"
        "4. The percentages should reflect your confidence in each answer's correctness\n"
        "5. Percentages do NOT need to sum to 100%\n"
        "6. If you're very confident an answer is correct, use 100%\n"
        "7. If you're very confident an answer is incorrect, use 0%\n"
        "8. Use any percentage in between for partial correctness (e.g., 13%, 42%, 87%, etc.)\n"
        "9. Only include the question and answer options, omit any other text\n"
        "10. If there are typos in the OCR text, correct them in your response\n"
        "11. If the text doesn't contain a complete question, respond with \"Incomplete question detected\"\n"
        "12. Analyse the text carefully to determine whether a space in text means it is a new answer on a new line, or may be part of the same answer. A space does not always mean it's a new answer — think of the context of the question and the answers to logically work out if it's a new answer or part of the same one.\n"
        "13. If multiple answer options appear on the same line or within the same paragraph, treat them as a flat list of distinct answer choices when appropriate. Use domain knowledge to split them sensibly. Do not mistakenly extract unrelated UI text or irrelevant screen elements as answer options.\n"
        "14. If the question instructs to select multiple answers (for example, \"select 2 answers\", \"select 3 answers\", etc.), ensure that no more than the required number of answers have a confidence percentage above 75%. This forces you to carefully evaluate and select only the most likely correct answers for multiple-selection questions, and prevents marking more than the specified number as highly confident.\n"
        "15. When extracting answer options, always preserve the original order as presented on the website or in the OCR text. Do not reorder, sort, or group the answers differently—return them in the exact sequence they appear in the source.\n"
        "16. If any text you receive is clearly not part of the question or answer set due to it not making sense or not being in context, first consider if there is a typo, and if not if you are certain it makes no sense, exclude it completely - for example website adverts or promotions.\n\n"
        "Also at the bottom of your answer, present to me all the answers and their % in this format;  A:50%, B:20%, C:100%, etc etc.\n\n"
        "OCR Context:\n"
        "- The text you will receive is generated by OCR\n"
        "- It is capturing the entire screen including text which is not related to the exam\n"
        "- Make sure you exclude anything clearly not related to the question and answer\n"
        "- The OCR text capture may include typos, if you spot any, fix them\n"
        "- Do not mark an answer as incorrect because the OCR scanned incorrectly and introduced a typo!\n"
        "- If you see multiple questions, only analyze the most complete one\n"
        "- If you see navigation elements or other UI elements, ignore them\n"
        "------------------------\n"
        "OCR Extract:\n"
        f"{text}\n"
    )

def send_to_openai(prompt: str) -> str:
    response = client.chat.completions.create(
        model="gpt-4o",  # Use the best available model
        messages=[{"role": "user", "content": prompt}],
        temperature=0,
    )
    return response.choices[0].message.content

def parse_answers(response):
    """
    Parses AI response like:
    Question: ...
    A (0%) ...
    B (0%) ...
    C (0%) ...
    D (100%) ...
    ...
    A:0%, B:0%, C:0%, D:100%
    """
    # Try to find the summary line first (e.g., A:0%, B:0%, ...)
    summary_match = re.search(r'([A-H]:\d+%[, ]*)+', response)
    if summary_match:
        summary = summary_match.group(0)
        pairs = re.findall(r'([A-H]):(\d+)%', summary)
        labels = []
        confidences = []
        for label, conf in pairs:
            labels.append(label)
            confidences.append(float(conf))
        # Pad to 8 if needed
        while len(labels) < 8:
            labels.append('NA')
            confidences.append(0.0)
        return labels, confidences

    # Fallback: Try to parse from the answer lines (A (0%) ...)
    answer_lines = re.findall(r'^([A-H])\s*\((\d+)%\)', response, re.MULTILINE)
    if answer_lines:
        labels = []
        confidences = []
        for label, conf in answer_lines:
            labels.append(label)
            confidences.append(float(conf))
        while len(labels) < 8:
            labels.append('NA')
            confidences.append(0.0)
        return labels, confidences

    # If nothing found, return all NA
    return ['NA'] * 8, [0.0] * 8

def map_confidence_to_colors(confidences: list, labels: list) -> list:
    colors = []
    for label, conf in zip(labels, confidences):
        if label == "NA" and conf == 0.0:
            colors.append('b')  # blue: no answer
        elif conf > 90.0:
            colors.append('g')  # green: >90%
        elif 50.0 <= conf <= 90.0:
            colors.append('a')  # amber: 50-90%
        elif conf < 50.0:
            colors.append('r')  # red: <50%
        else:
            colors.append('b')  # fallback
    return colors