import os
import re
import openai
from typing import Dict, Any
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get OpenAI API key
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if OPENAI_API_KEY:
    client = openai.OpenAI(api_key=OPENAI_API_KEY)
else:
    print("WARNING: OPENAI_API_KEY not found in environment variables.")
    client = None

def get_exam_type():
    """Read the exam type from exam_type.txt file."""
    try:
        exam_type_file = os.path.join(os.path.dirname(__file__), "exam_type.txt")
        if os.path.exists(exam_type_file):
            with open(exam_type_file, "r") as f:
                exam_type = f.read().strip()
                # Use a default if the file is empty
                if not exam_type:
                    return "IT certification"
                return exam_type
        else:
            # If file doesn't exist, create it with a default value
            with open(exam_type_file, "w") as f:
                f.write("IT certification")
            return "IT certification"
    except Exception as e:
        print(f"Error reading exam type: {e}")
        return "IT certification"  # Default fallback

def build_extraction_prompt(ocr_text: str) -> str:
    """Build a prompt for the extraction-only task."""
    exam_type = get_exam_type()
    
    prompt_text = f"""
We are extracting exam questions. You are an expert in {exam_type} certification exams. Analyze the following text from a practice exam question and extract ONLY the question and answer options. Do NOT evaluate which answers are correct - just extract and format the content.

Example format:
Question: [The actual question text]
A: [Answer A text]
B: [Answer B text]
C: [Answer C text]
D: [Answer D text]

Important:
1. Do NOT include any evaluations, percentages, or indicators of correctness
2. Just extract and format the question and answer options
3. Format as shown above with the letter and colon (e.g., "A: [text]")
4. If there are typos in the OCR text, correct them in your response
5. If the text doesn't contain a complete question, respond with "Incomplete question detected"
6. Analyze the text carefully to determine whether a space means it's a new answer on a new line
7. If multiple answer options appear on the same line, treat them as distinct answer choices
8. Only include the question and answer options, omit any other text
9. For True/False questions, format as "A: True" and "B: False"
10. If any text is clearly not part of the question or answer set, exclude it

OCR Context:
- The text you will receive is generated by OCR
- It is capturing the entire screen including text which is not related to the exam
- Make sure you exclude anything clearly not related to the question and answer
- If you see multiple questions, only extract the most complete one
- If you see navigation elements or other UI elements, ignore them

------------------------
OCR Extract:
{ocr_text}
"""
    return prompt_text

def extract_question(ocr_text: str) -> Dict[str, Any]:
    """Extract just the question and answer options, without evaluating correctness."""
    prompt = build_extraction_prompt(ocr_text)
    
    if not OPENAI_API_KEY:
        return {"error": "OpenAI API key is missing"}
    
    try:
        # Call the OpenAI model to extract the question and answers
        response = client.chat.completions.create(
            model="gpt-4",  # You can change this to gpt-3.5-turbo if needed
            messages=[
                {"role": "system", "content": "You are a helpful assistant that extracts exam questions and answer options without evaluating them."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=1000,
            temperature=0.0  # Keep deterministic
        )
        
        # Process the response
        if hasattr(response, 'choices') and len(response.choices) > 0:
            extracted_text = response.choices[0].message.content
            
            # Parse the extracted content into a structured format
            structured_content = parse_extracted_content(extracted_text)
            return structured_content
        else:
            return {"error": "Empty or invalid response from OpenAI"}
    
    except Exception as e:
        error_msg = f"Error calling OpenAI API: {e}"
        print(error_msg)
        return {"error": str(e)}

def parse_extracted_content(extracted_text: str) -> Dict[str, Any]:
    """Parse the extracted text into a structured format."""
    result = {
        "question": "",
        "options": {}
    }
    
    # Check for incomplete question
    if "Incomplete question detected" in extracted_text:
        return {"error": "Incomplete question detected"}
    
    # Extract the question
    question_match = re.search(r"Question: (.+?)(?=\nA:|$)", extracted_text, re.DOTALL)
    if question_match:
        result["question"] = question_match.group(1).strip()
    
    # Extract answer options
    option_pattern = r"([A-Z]): (.+?)(?=\n[A-Z]:|$)"
    options = re.findall(option_pattern, extracted_text, re.DOTALL)
    
    for letter, text in options:
        result["options"][letter] = text.strip()
    
    return result

if __name__ == "__main__":
    # Test function
    test_ocr = """
    Which of the following is a benefit of information security governance?
    A Direct involvement of senior management in developing control processes
    B Reduction of the potential for civil and legal liability
    C Questioning the trust in vendor relationships
    D Increasing the risk of decisions based on incomplete management information
    """
    
    result = extract_question(test_ocr)
    print("Extracted content:")
    print(f"Question: {result.get('question')}")
    print("Options:")
    for letter, text in result.get('options', {}).items():
        print(f"{letter}: {text}")